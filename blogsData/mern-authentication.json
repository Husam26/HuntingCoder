{
    "id": "mern-authentication",
    "title": "User Authentication in MERN Stack",
    "excerpt": "A step-by-step guide on implementing user authentication with JWT in a MERN stack application.",
    "image": "/blog7.jpg",
    "link": "/blogpost/mern-authentication",
    "date": "2025-03-08",
    "content": "### **Introduction**\n\nUser authentication is an essential part of building secure applications. In this guide, we'll learn how to implement user authentication using **JSON Web Tokens (JWT)** in a **MERN stack** application (MongoDB, Express, React, Node.js). We will cover backend setup for handling user authentication and frontend implementation to protect routes and handle user login.\n\n### **1. Setting Up the Backend (Node.js + Express)**\n\nFirst, we'll create a backend using **Node.js** and **Express** to handle user authentication. We'll need to install the following dependencies:\n\n```bash\nnpm install express mongoose bcryptjs jsonwebtoken dotenv\n```\n\n#### **Create a User Model**\nIn your **models** folder, create a file called `User.js` that will define the schema for storing user information in MongoDB.\n\n```javascript\nconst mongoose = require('mongoose');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\n\nconst userSchema = new mongoose.Schema({\n  name: { type: String, required: true },\n  email: { type: String, required: true, unique: true },\n  password: { type: String, required: true },\n}, { timestamps: true });\n\n// Hash password before saving\nuserSchema.pre('save', async function (next) {\n  if (!this.isModified('password')) return next();\n  this.password = await bcrypt.hash(this.password, 10);\n  next();\n});\n\n// Compare password for login\nuserSchema.methods.comparePassword = async function (password) {\n  return await bcrypt.compare(password, this.password);\n};\n\n// Generate JWT\nuserSchema.methods.generateAuthToken = function () {\n  const token = jwt.sign({ id: this._id }, process.env.JWT_SECRET, { expiresIn: '1h' });\n  return token;\n};\n\nmodule.exports = mongoose.model('User', userSchema);\n```\n\n#### **Create Auth Routes**\nCreate a new route file for authentication (e.g., `authRoutes.js`). This file will handle the user login and registration logic.\n\n```javascript\nconst express = require('express');\nconst User = require('../models/User');\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcryptjs');\n\nconst router = express.Router();\n\n// Register User\nrouter.post('/register', async (req, res) => {\n  const { name, email, password } = req.body;\n  try {\n    let user = await User.findOne({ email });\n    if (user) return res.status(400).json({ error: 'User already exists' });\n    user = new User({ name, email, password });\n    await user.save();\n    const token = user.generateAuthToken();\n    res.status(201).json({ token });\n  } catch (error) {\n    res.status(500).json({ error: 'Server error' });\n  }\n});\n\n// Login User\nrouter.post('/login', async (req, res) => {\n  const { email, password } = req.body;\n  try {\n    let user = await User.findOne({ email });\n    if (!user) return res.status(400).json({ error: 'Invalid credentials' });\n    const isMatch = await user.comparePassword(password);\n    if (!isMatch) return res.status(400).json({ error: 'Invalid credentials' });\n    const token = user.generateAuthToken();\n    res.json({ token });\n  } catch (error) {\n    res.status(500).json({ error: 'Server error' });\n  }\n});\n\nmodule.exports = router;\n```\n\n#### **Set Up Environment Variables**\nIn your project root, create a `.env` file to store sensitive information like the JWT secret.\n\n```env\nJWT_SECRET=your_jwt_secret\nMONGO_URI=your_mongo_connection_string\n```\n\nMake sure to use **dotenv** to load environment variables into your app.\n\n#### **Set Up Express Server**\nNow, set up your Express server to use the authentication routes and connect to MongoDB.\n\n```javascript\nconst express = require('express');\nconst mongoose = require('mongoose');\nconst dotenv = require('dotenv');\nconst authRoutes = require('./routes/authRoutes');\n\ndotenv.config();\n\nconst app = express();\napp.use(express.json());\n\nmongoose.connect(process.env.MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true }).then(() => {\n  console.log('MongoDB connected');\n}).catch((err) => {\n  console.error('MongoDB connection error:', err);\n});\n\napp.use('/api/auth', authRoutes);\n\napp.listen(5000, () => {\n  console.log('Server running on port 5000');\n});\n```\n\n### **2. Setting Up the Frontend (React)**\n\nNow, let’s create a frontend in **React** to handle user authentication. We will use **Axios** to make HTTP requests and **React Context API** for managing the authentication state.\n\nFirst, install Axios:\n\n```bash\nnpm install axios\n```\n\n#### **Create an Auth Context**\nCreate a new file called `AuthContext.js` to manage the user's authentication state.\n\n```javascript\nimport React, { createContext, useState, useEffect } from 'react';\nimport axios from 'axios';\n\nconst AuthContext = createContext();\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    const token = localStorage.getItem('authToken');\n    if (token) {\n      axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n      setUser(token);\n    }\n  }, []);\n\n  const login = async (email, password) => {\n    try {\n      const { data } = await axios.post('http://localhost:5000/api/auth/login', { email, password });\n      localStorage.setItem('authToken', data.token);\n      axios.defaults.headers.common['Authorization'] = `Bearer ${data.token}`;\n      setUser(data.token);\n    } catch (error) {\n      console.error('Login error:', error);\n    }\n  };\n\n  const logout = () => {\n    localStorage.removeItem('authToken');\n    setUser(null);\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, login, logout }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => React.useContext(AuthContext);\n```\n\n#### **Create Login Component**\nNow, create a `Login.js` component to handle user login.\n\n```javascript\nimport React, { useState } from 'react';\nimport { useAuth } from './AuthContext';\n\nconst Login = () => {\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const { login } = useAuth();\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    login(email, password);\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"p-6 bg-white shadow-lg rounded-lg\">\n      <input type=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} placeholder=\"Email\" required className=\"w-full p-3 border rounded-md mb-4\" />\n      <input type=\"password\" value={password} onChange={(e) => setPassword(e.target.value)} placeholder=\"Password\" required className=\"w-full p-3 border rounded-md mb-4\" />\n      <button type=\"submit\" className=\"w-full bg-blue-600 text-white p-3 rounded-md\">Login</button>\n    </form>\n  );\n};\n\nexport default Login;\n```\n\n### **3. Protecting Routes with JWT**\n\nYou can protect certain routes by checking the JWT in the frontend. For example, in a React component, you can check if a token exists in `localStorage` before rendering a protected page.\n\n```javascript\nimport React from 'react';\nimport { useAuth } from './AuthContext';\n\nconst ProtectedPage = () => {\n  const { user } = useAuth();\n\n  if (!user) {\n    return <div>You need to login first.</div>;\n  }\n\n  return <div>Protected Content</div>;\n};\n\nexport default ProtectedPage;\n```\n\n### **Conclusion**\n\nThis guide has covered how to implement user authentication in a MERN stack application using JWT. We’ve set up a backend with Node.js and Express to handle user registration, login, and token generation. On the frontend, we’ve used React to manage authentication state and protect routes with JWT.\n\nBy using JWT for user authentication, you can build secure and scalable applications with the MERN stack."
  }
  